#!/usr/bin/bash

input_service="${1}"
how_many_disabled=0
list_of_service=""

sanity_checks() {
        if [[ ${#} -ne 1 || ! "${input_service}" =~ [[:alnum:]]{1,}\/[[:alnum:]]{1,} ]]; then
                printf "\n %s\n %s\n\n" "***$(date)***" "[ ERROR - you need to enter a valid service as a first argument. Ex: cups/in-lpd ]"
                exit
        fi
}

sanity_checks "${@}"

#this array, list_of_services, is populated automatically with the service itself, which is an argument when you lunch the script and all dependencies, 
#but you can also rewrite it and you can mentioned here #the service and dependencies you want. Maybe you do not want to recover all the dependencies or it is not necessary.

list_of_services+=( ${input_service} $(svcs -d -H "${input_service}" | awk '{print $3}') )

printing_header() {
        printf "\n%s\n" "$(date)"
        printf "%60s\n" " " | tr " " "-"
        printf "%s\n\n" "   [ Given service: ${input_service} ]"
}

printing_footer() {
        printf "%60s\n" " " | tr " " "-"
        printf "%60s\n\n" "made with love for tshooting"
}

checking_services_states() {
        for i in "${list_of_services[@]}"; do
                
                full_state="$(svcs -o state "${i}" | ggrep -v -i "state")"
                
                if [[ "${full_state}"  == "disabled" ]]; then
                        disabled_services+=("${i}")       
                elif [[ "${full_state}" == "online" ]]; then
                        enable_services+=("${i}")
                fi
        done

        how_many_disabled="${#disabled_services[@]}"
}
 
action_on_all_services() {
        type_of_action="${1}"
        if [[ "${type_of_action}" == "disable" ]]; then
                for i in "${list_of_services[@]}"; do
                        svcadm "${type_of_action}" "${i}"
                done
        elif [[ "${type_of_action}" =~ enable|refresh|restart ]]; then
                for (( i=${#list_of_services[@]}-1; i>=0; i-- )); do
                        svcadm "${type_of_action}" "${list_of_services[i]}"
                done
        fi
}

exec_action_one_by_one() {
        input_service="${1}"
        action_type="${2}"
        svcadm "${action_type}" "${input_service}"
}

pr_type() {
        type_of_input=( "$@" )
        counter="${#type_of_input[@]}"
        for (( i=0; i<counter; i++ )); do
                if [[ ${i} -lt $((counter-1)) ]]; then
                        printf "%s" "${type_of_input[i]}, "
                else
                        printf "%s\n" "${type_of_input[i]}"
                fi
        done
}

printing_disabled_services_states() {
        if [[ "${#disabled_services[@]}" -ne 0 ]]; then
                printf "%s" "**Disabled state: "
                pr_type "${disabled_services[@]}"
        else
                printf "%s\n" "**No service in disabled state."
        fi

}

printing_enable_services_states() {
        if [[ "${#enable_services[@]}" -gt 0 ]]; then
                printf "%s" "***Enabled state: "
                pr_type "${enable_services[@]}"
        else
                printf "%s\n" "**No service in enabled state."
        fi
}

main() {
        actions=("disable" "enable" "refresh" "restart")
        checking_services_states
        
        [[ "${how_many_disabled}" -eq 0 ]] && { exit; }
        
        output="$(if [[ ${how_many_disabled} -ne 0 ]]; then
                        
                        printing_header 
                        printing_disabled_services_states
                        printing_enable_services_states

                        for j in "${actions[@]}"; do
                                action_on_all_services "${j}"
                        done

                        printf "\n%s\n\n" "-->Perform recovering actions on: $(pr_type "${disabled_services[@]}")"
                        sleep 20     #### wait 20 seconds and then check the service with dependencies to see if recovering was completed with success.
                        printf "\n%s\n%s\n%s\n" "--->After recovering:" "$(svcs -H ${input_service})" "$(svcs -d -H ${input_service})"  
                        printing_footer

                fi)"
        
        #you can choose where these messages that are generated by this script are stored. In logger command after -f you need to put a file
        
        logger -t "${input_service}_maintenance" -p error "${output}"
}

main "${@}"